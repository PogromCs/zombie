					/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <sqlx>
#include <cstrike>
#include <hamsandwich>
#include <engine>
#include <fakemeta>
#include <fun>

#define PLUGIN "Osiagniecia Zombie Mod"
#define VERSION "1.0.1"
#define AUTHOR "Pogrom"
#include <zp50_core>
#include <zp50_gamemodes>
#include <zp50_colorchat>
#include <zp50_class_human>
#include <zp50_class_zombie>
#define LIBRARY_NEMESIS "zp50_class_nemesis"
#include <zp50_class_nemesis>
#define LIBRARY_ASSASIN "zp50_class_assassin"
#include <zp50_class_assassin>
#define LIBRARY_SURVIVOR "zp50_class_survivor"
#include <zp50_class_survivor>
#define LIBRARY_SNIPER "zp50_class_sniper"
#include <zp50_class_sniper>
#define LIBRARY_AMMOPACKS "zp50_ammopacks"
#include <zp50_ammopacks>
#include <colorchat>
#include "osiagniecia.cfg"
#define g_maxplayers 32


#define TASK_LOAD_STATS 1550

#define TASK_OFFSET 1500
new const prefix[] = "OSIAGNIECIA"
new ZapiszStats[8000]
new giLen=0, giMax=sizeof(ZapiszStats) - 1
new callback
new data[6]
new dostep;
new name[32]

enum {
ap = 0,
dmg = 1,
zombie,
inf,
death,
nemesis,
survivor,
assassin,
sniper,
matka,
human,
czas,
rundy



}
native get_user_xp(id);
native set_user_xp(id, amount);
native give_lm(id,ilosc);
native daj_bombe(id);
native ap_bonus_add(id,ilosc);

//dodajac usuwajac osiagniecia trzeba zmieniac funkcje wylicz i check oraz definicje powyzej oraz sql + dodac wymaagnia nagrody ppre i osiangiecia
new ilosc[33][LICZBA_OSIAGNIEC] 
new g_stats[33][LICZBA_OSIAGNIEC]


new command[][] = { "/osiagniecia","/achievements","/achieve"}
new chat[][] = {"say","say_team" };
new comm[][] = {"/osiagenieciainfo","/achievementsinfo","/achieveinfo","/infoachieve","/infoosiagniecia","/infoachievements"}



new g_sqlTable[31]= "zm_osiagniecia_testy"	
new mysqlx_host, mysqlx_user, mysqlx_db, mysqlx_pass
new min_player,p_Enabled
new asked_sql[33];
new g_boolsqlOK = 0
new Handle:g_SqlTuple
new bool:wczytalo[33] = false


new paka =0

new ilosc_wpisow = 0
public plugin_init() {
	register_plugin(PLUGIN, VERSION, AUTHOR)

	for (new i = 0; i <sizeof chat;i++)
		register_clcmd(chat[i],"Say_Handle")
		
	min_player = get_cvar_pointer("min_liczba_graczy")
	p_Enabled = register_cvar("o_enable","1")
	mysqlx_host = register_cvar ("o_host", "localhost"); // The host from the db
	mysqlx_user = register_cvar ("o_user", "root"); // The username from the db login
	mysqlx_pass = register_cvar ("o_pass", ""); // The password from the db login
	mysqlx_db = register_cvar ("o_dbname", "db"); // The database name 
	
	register_menucmd(register_menuid("Main Menu"), 1023, "menu_osiagniecia_handle2")
	
	RegisterHam(Ham_TakeDamage, "player", "TakeDamage");
	register_event("DeathMsg", "event_deathmsg", "a");
	register_event("Damage", "on_damage", "b", "2!0", "3=0", "4!0")	
	
	register_logevent("Poczatek_Rundy", 2, "1=Round_Start")
	register_logevent("EventRoundEnd", 2, "1=Round_End")
	set_task(1.0, "sql_start")
	set_task(60.0, "increaseMinutes", .flags="b")
	set_task(60.0, "TaskZapiszStats", 0, _, _, "b")
	//register_concmd("osc","cmd_oc",ADMIN_IMMUNITY)
	ResetujZapytanie()
	
	
}


public plugin_natives()
{
	register_native("load_stat","native_load_stat",1)
	register_native("add_ap_stat","native_add_ap",1)
	register_native("add_achieve","native_add_achieve",1)
} 
public native_add_achieve(id,nr){
	server_print("%d %d", id , nr)
	g_stats[id][nr] = osiagniecia_wymagania[nr][ilosc[id][nr]]
	ilosc[id][nr]++
}
public native_load_stat(id,nr)
{	
	if(!is_user_connected(id))
		return 0
	if(wczytalo[id])
		return ilosc[id][nr]
	return 0 
	
}

public native_add_ap(id){
	g_stats[id][0]++
	check(id)
}
public on_damage(id){
	new attacker_id = get_user_attacker(id)
	new damage = read_data(2);
	
	if(!is_user_connected(id) || !is_user_connected(attacker_id) || get_user_team(id) == get_user_team(attacker_id) || !is_user_alive(id) || zp_class_nemesis_get(attacker_id) || zp_class_survivor_get(attacker_id) || zp_class_sniper_get(attacker_id) || zp_class_assassin_get(attacker_id))
		return PLUGIN_CONTINUE;
	
	g_stats[attacker_id][dmg] += damage
	check(attacker_id)
	return PLUGIN_CONTINUE;
}
	

public Poczatek_Rundy()
{
	new ammount = 0;
	if(players_num() < get_pcvar_num(min_player))
		{
			//ColorChat(g_attacker,GREEN,"[%s] Za mala liczba graczy aby osiagniecia byly naliczane",prefix)
			return 
					
		}
	for (new i = 1 ; i<33;i++)
	{
		if(!is_user_connected(i))
			continue;
		if(ilosc[i][ap] >=1)
			ammount++
		if(ilosc[i][ap] >= 3)
			ammount++
		if(ilosc[i][ap] >= 5)
			ammount +=2
		if (ammount > 0){ // ap co runde
			zp_ammopacks_set(i,zp_ammopacks_get(i) +ammount)
			ap_bonus_add(i,ammount)
		}
	}
	
}

public EventRoundEnd()
{	
	if(players_num() < get_pcvar_num(min_player)){
		ColorChat(0,GREEN,"[%s] ^x01 Za mala liczba graczy",prefix)
		return
	}
	for (new id=1; id < 33; id++) {
		if(!is_user_connected(id) || !is_user_alive(id) )
			continue;
		
		if(!zp_core_is_zombie(id))
			g_stats[id][rundy]++
	
	}
}



public zp_fw_core_spawn_post(id)
{
	set_task(10.0, "Bonusy", id);
	
}

public Bonusy(id)
{
	new dodatkowe_hp = 0
	new dodatkowy_armor = 0
	
	if (zp_core_is_zombie(id) && !zp_class_assassin_get(id)&& !zp_class_nemesis_get(id))
	{
		if(ilosc[id][zombie] >= 1)
		{
			dodatkowe_hp += 100
			
		}
		if(ilosc[id][zombie] >= 2){
			dodatkowe_hp += 150
			
		}
		if(ilosc[id][zombie] >= 3)
		{
			dodatkowe_hp += 200
			
			
		}
		if(ilosc[id][zombie] >= 4){
			dodatkowe_hp += 200
			
		}
		if(ilosc[id][zombie] >= 5){
			dodatkowe_hp += 250
			
		}
			
		if(dodatkowe_hp >0){
			set_user_health(id, get_user_health(id) + dodatkowe_hp)
			ColorChat(id,GREEN,"[%s] ^x01 Otrzymales dodatkowe  ^x04  %d  ^x01 hp za osiagniecia",prefix,dodatkowe_hp)
		}
	}
	else {	
		
		if(ilosc[id][matka] >= 1){
			dodatkowy_armor += 5
			
			
		}
		if(ilosc[id][matka] >= 2){
			dodatkowy_armor += 10
			
			
		}
		if(ilosc[id][matka] >= 3){
			dodatkowy_armor += 10
			
		}
		
		if(ilosc[id][matka] >= 4){
			dodatkowy_armor += 15
			
		}
	
		if(ilosc[id][matka] >= 5){
			dodatkowy_armor += 15
			
		}
		
		
		if(dodatkowy_armor > 0){
			set_user_armor(id, get_user_armor(id) + dodatkowy_armor)
			ColorChat(id,GREEN,"[%s] ^x01 Otrzymales dodatkowe ^x04 %d  ^x01 armoru za osiagniecia ",prefix,dodatkowy_armor)
		}
		if (ilosc[id][rundy] == 5)
			give_lm(id,3)
		else if (ilosc[id][rundy] >= 3) 
			give_lm(id,2)
		else if (ilosc[id][rundy] >= 1) 
			give_lm(id,1)
	}

		
}

//===============================================
//Pobieranie tekstu z say i sprawdzanie komend"
//===============================================
public Say_Handle(id)
{
	new text[70], arg1[32], arg2[32]
	read_args(text, sizeof(text)-1)
	remove_quotes(text)
	
	arg1[0] = '^0'
	arg2[0] = '^0'
	
	
	parse(text, arg1, sizeof(arg1)-1, arg2, sizeof(arg2)-1)
	//for(new i =0; i<sizeof comm;i++){
		//if(equali(arg1, comm[i])){
		//	osiagniecia_info(id)
		//	return PLUGIN_HANDLED
		//}
	//}
	if(arg2[0] == 0 )
	{ 	
		for(new i = 0;i<sizeof comm;i++){
			if(equali(arg1, comm[i])){
				osiagniecia_info(id)
				return PLUGIN_HANDLED
			}
		}
	
		for (new i = 0;  i <sizeof command;i++){
			if(equali(arg1,command[i])){
				if (!g_boolsqlOK || !wczytalo[id]){
					ColorChat(id,GREEN,"[%s] ^x01 Trwa wczytywanie danych prosze czekac",prefix)
					Sprawdz_baze(id) 
					return PLUGIN_HANDLED
				}
				menu_osiagniecia(id)
				return PLUGIN_HANDLED
			}
			
		}
		return PLUGIN_CONTINUE
		

	}
	return PLUGIN_CONTINUE
	
}
//========================
//Info o osiagnieciach
//========================

public osiagniecia_info(id)
{
	
}

//====================
//Menu osiagniec
//====================
public menu_osiagniecia(id)
{
	new menu = menu_create("\yMenu \rOsiagniec","menu_osiagniec_handle")
	new formats[192]
	new data2[15]
	for(new i = 0;i<LICZBA_OSIAGNIEC;i++)
	{
		if(ilosc[id][i] < 5)
			formatex(formats,sizeof formats,"\w%s (%d/5)", osiagniecia[i],ilosc[id][i]);
		
		else 
			formatex(formats,sizeof formats,"\d%s\r[UKONCZONE]", osiagniecia[i])
		num_to_str(i,data2,sizeof(data2))
		menu_additem(menu,formats,data2,0);
	}
	menu_display(id,menu)
}

public menu_osiagniec_handle(id,menu,item)
{		
	
	
	menu_item_getinfo(menu, item, dostep, data, 5, name, 31, callback);
	if (item == MENU_EXIT)
		return;
	
	new item_id ;
	item_id = str_to_num(data)
	static formats[1024], iLen;
	iLen = 0;
	new xKeys3 = MENU_KEY_0|MENU_KEY_1;
	iLen += formatex(formats[iLen], sizeof formats - 1 - iLen, "\y Osiagniecia - \r %s ^n^n",ppre[item_id])
	//new menu2 = 
	for(new i = 0;i<MAX_ACHIEVE;i++)
	{	
		if(i + 1 > ilosc[id][item_id]) //jezeli i bedzie wieksze niz to co ma juz ukonczone w tej katgeori to dodaje zakres 
			iLen += formatex(formats[iLen], sizeof formats - 1 - iLen,"\w %s \r(%d / %d) \y nagroda:\w %s^n", poddzialy[i],g_stats[id][item_id],osiagniecia_wymagania[item_id][i],nagrody[item_id][i]);
			
		else 	
			iLen += formatex(formats[iLen], sizeof formats - 1 - iLen,"\d %s \r[UKONCZONE] \y nagroda:\w %s^n", poddzialy[i],nagrody[item_id][i])
		
	}
	iLen+= formatex(formats[iLen],sizeof formats - 1 - iLen,"\r1. \wCofnij")
	iLen += formatex(formats[iLen], sizeof formats - 1 - iLen, "^n^n\r0.\w Wyjdz.")
	
	show_menu(id, xKeys3, formats, -1, "Main Menu")
	//menu_display(id,menu2)
}
public menu_osiagniecia_handle2(id, key)

{
	switch(key){
		case 0: {
				menu_osiagniecia(id)
			}
		case 9:
			{
				return PLUGIN_HANDLED;
			}
		}
	return PLUGIN_CONTINUE
}
//===================================
//Sprawdzenie czy nalezy sie nagroda
//===================================
public check(id)
{	
	for(new i = 0;i>12;i++)
	{
		for(new g=0;g<5;g++)
		{
			if(g_stats[id][i] >= osiagniecia_wymagania[i][g] &&  g+1>ilosc[id][i])
			{
				ilosc[id][i]++
				ColorChat(id,GREEN,"[%] ^x01Osiagnales osiagniecie ^x03 %s ^x01 na poziomie ^x03 %s",prefix,osiagniecia[i],poddzialy[g])
				
			}
				
					
		}
	}
}

//==================================================================
//Sprawdzenie ktore osiagniecia juz wykonal gracz i w jakiej ilosc
//==================================================================
public wylicz(id)
{
	for(new i = 0;i<LICZBA_OSIAGNIEC;i++)
		for(new g=0;g<MAX_ACHIEVE;g++)
		{
			if(g_stats[id][i] >= osiagniecia_wymagania[i][g] )
			{
				ilosc[id][i]++
			}
			
		}
	
}

//=================================================================================
//funkcja zwracajaca liczbe graczy bedacych na serwerze oraz nie bedacych na spec
//=================================================================================
public players_num(){
	new liczba= 0;
	for(new i=1; i < 33; i++)
	{
		
		if(is_user_bot(i) || is_user_hltv(i) || !is_user_connected(i))
			continue;	
		new CsTeams:team = cs_get_user_team(i)
		if(team == CS_TEAM_SPECTATOR && team == CS_TEAM_UNASSIGNED)
			continue
		liczba++;
	}
	return liczba
}
//====================================================
//Pobranie czasu spï¿½dzonego na serwerze przez gracza
//====================================================
public increaseMinutes()
{	
	
	if(players_num() < get_pcvar_num(min_player))
	{
		ColorChat(0,GREEN,"[%s]  ^x01Za mala liczba graczy aby czas byl naliczany",prefix)
		return PLUGIN_CONTINUE
				
	}
	new players[32], pnum, tempid
	get_players(players, pnum)
	
	for(new i; i<pnum; i++)
	{
		tempid = players[i]
		new CsTeams:team = cs_get_user_team(tempid)
		
		if(team != CS_TEAM_SPECTATOR && team != CS_TEAM_UNASSIGNED)
		{
			g_stats[tempid][11]++
		}
	}
	return PLUGIN_CONTINUE
}




//================
//statystki osiagniec
//=================


public event_deathmsg()
{		
		if( !get_pcvar_num(p_Enabled) )
			return;
		if(players_num() < get_pcvar_num(min_player))
		{
			//ColorChat(g_attacker,GREEN,"[%s] Za mala liczba graczy aby osiagniecia byly naliczane",prefix)
			return 
					
		}
		new g_attacker = read_data(1);
		new g_victim = read_data(2);
		new ap_vic = 0,exp_vic =0,exp_att = 0, ap_att = 0
		
		//nagroda za osiaecingia zginiecia
		if (ilosc[g_victim][death] == 5)
		{
			ap_vic +=1	
		}
		if (ilosc[g_victim][death] >= 3)
		{
			ap_vic +=1
		}
		if (ilosc[g_victim][death] >= 1)
		{
			ap_vic +=1
		}
		
		if (ilosc[g_victim][death] >= 4)
			exp_vic += 2
			
		if (ilosc[g_victim][death] >= 2)
			exp_vic += 2
		if (ap_vic >0){
			ColorChat(g_victim,GREEN,"[%s] ^x01 Otrzymales  ^x04 %d  ^x01 dodatkowego  ^x04 ap ^x01 z osiagniec",prefix,ap_vic)
			zp_ammopacks_set(g_victim,zp_ammopacks_get(g_victim) + ap_vic)
			ap_bonus_add(g_victim,ap_vic)
		}
		if(exp_vic >0)
		{	
			ColorChat(g_victim,GREEN,"[%s]  ^x01 Otrzymales  ^x04 %d ^x01 dodatkowego  ^x04 exp ^x01 z osiagniec",prefix,exp_vic)
			set_user_xp(g_victim,get_user_xp(g_victim) + exp_vic)
		}
		
		
		//nagroda za osiagniecia zabicia zm
		
		if (ilosc[g_attacker][zombie] >= 4)
			exp_att += 2
		if (ilosc[g_attacker][zombie] >= 3)
			exp_att += 2
		if (ilosc[g_attacker][zombie] >= 2)
			exp_att += 1	
		if(ilosc[g_attacker][zombie] >= 1)
			ap_att +=1
			
		// exp i ap  za osiagniecie nemkow	
		if(ilosc[g_attacker][nemesis] >= 4 && zp_class_nemesis_get(g_victim))
			exp_att += 10
			
		if (ilosc[g_attacker][nemesis] >= 2 && zp_class_nemesis_get(g_victim))
			exp_att += 5
			
		if (ilosc[g_attacker][nemesis] >= 3  && zp_class_nemesis_get(g_victim))
		{
			ap_att +=5
		}
		if (ilosc[g_attacker][nemesis] >= 1  && zp_class_nemesis_get(g_victim))
		{
			ap_att +=2
		}	
		
		if(ilosc[g_attacker][ap] >= 4 && random_num(1,100) <=5){
			exp_att +=  random_num(10,25)
			
		}
		if(ilosc[g_attacker][ap] >= 2 && random_num(1,100) <=5)
			exp_att +=   random_num(5,20)
		if(ap_att > 0)
		{	
			ColorChat(g_attacker,GREEN,"[%s]  ^x01Otrzymales  ^x04 %d  ^x01 dodatkowego  ^x04 ap  ^x01 z osiagniec",prefix,ap_att)
			zp_ammopacks_set(g_attacker,zp_ammopacks_get(g_attacker) + ap_att)
			ap_bonus_add(g_attacker,ap_att)
		}
		if(exp_att > 0){
			ColorChat(g_attacker,GREEN,"[%s]  ^x01 Otrzymales  ^x04 %d  ^x01 dodatkowego  ^x04 expa ^x01 z osiagniec",prefix,exp_att)
			set_user_xp(g_attacker,get_user_xp(g_attacker) + exp_att)
		}
		
		
		if(zp_core_is_zombie(g_victim) || zp_class_assassin_get(g_victim)|| zp_class_nemesis_get(g_victim)){
			g_stats[g_victim][4]++;
			check(g_victim)
		}
		if((1 <= g_attacker <= g_maxplayers))
		{
			if(g_victim != g_attacker)
			{
				
				if(zp_core_is_zombie(g_attacker))
				{
					g_stats[g_attacker][3]++
				}
				else
				{
					g_stats[g_attacker][2]++
				}
				
				
				if(zp_class_nemesis_get(g_victim))
				{
					
					g_stats[g_attacker][5]++
					
				}
				if(zp_class_survivor_get(g_victim))
				{
					g_stats[g_attacker][6] ++
				}
				if(zp_class_assassin_get(g_victim))
				{
					
					g_stats[g_attacker][7]++
					
				}
				if(zp_class_sniper_get(g_victim))
				{
					g_stats[g_attacker][8]++
				}
				
				new const Infection[] = "Infection Mode" 
				new InfectionID = zp_gamemodes_get_id(Infection)
				
				new const Multi[] = "Multiple Infection Mode" 
				new MultiID = zp_gamemodes_get_id(Multi)
				
				if(zp_core_is_last_human(g_victim) && (zp_gamemodes_get_current() == InfectionID || zp_gamemodes_get_current() == MultiID))
				{
					
					g_stats[g_attacker][10]++
					
				}
				else if(zp_core_is_first_zombie(g_victim) && (zp_gamemodes_get_current() == InfectionID || zp_gamemodes_get_current() == MultiID))
				{			
					g_stats[g_attacker][9]++
					
				}
			}
			
			check(g_attacker)
	}
}

//=================================
//Bonusy za osiagniete osiagniecia
//=================================

public TakeDamage(this, idinflictor, idattacker, Float:damage)
{
	if(!is_user_alive(this) || !is_user_connected(this) || !is_user_connected(idattacker) || get_user_team(this) == get_user_team(idattacker))
		return HAM_IGNORED;
	
	
	if((zp_class_sniper_get(idattacker) && (random_num(1,100) <= 4) && ilosc[this][sniper] ==5) || (zp_class_sniper_get(idattacker) && (random_num(1,100) <= 2) && ilosc[this][sniper] ==4) ||(zp_class_assassin_get(this) && random_num(1,100) <=3 && ilosc[this][7] == 4)  || (zp_class_assassin_get(this) && random_num(1,100) <=1 && ilosc[this][assassin] == 3))
		return HAM_SUPERCEDE
	new Float:am = 1.0
	if(ilosc[idattacker][dmg] >= 1)
		am += 0.01
	if(ilosc[idattacker][dmg] >= 2)
		am += 0.02
	if(ilosc[idattacker][dmg] >= 3)
		am += 0.02
	if(ilosc[idattacker][dmg] >= 4)
		am += 0.03
	if(ilosc[idattacker][dmg] == 5)
		am += 0.04
	if(zp_class_nemesis_get(this) && ilosc[idattacker][nemesis] == 5  )
		am += 0.06
	if(zp_class_survivor_get(idattacker) && ilosc[idattacker][survivor] == 5  )
		am += 0.04
	if(zp_class_survivor_get(idattacker) && ilosc[idattacker][survivor] >= 4  )
		am += 0.02
	if(zp_class_survivor_get(idattacker) && ilosc[idattacker][survivor] >= 2 )
		am += 0.02
	if(zp_class_sniper_get(this) && ilosc[idattacker][sniper] >=1)
		am += 0.03
	if(zp_class_sniper_get(this) && ilosc[idattacker][sniper] >=2)
		am += 0.06
	if(zp_class_sniper_get(this) && ilosc[idattacker][sniper] >=3)
		am += 0.09
	if(ilosc[idattacker][zombie]==5 && random_num(1,100) <=2)
		am+=0.5
		
	if (am >1.0)
		damage *= am
	
	
	
	SetHamParamFloat(4, damage);
	
	return HAM_IGNORED;
}

//============================================
//Polaczenie i rozlaczenie gracza z serwerem
//============================================
public client_connect(id)
{
	asked_sql[id]=0
	wczytalo[id] = false
	if(g_boolsqlOK)
		Loadstats(id)
	else set_task(3.0, "Sprawdz_baze", id+TASK_LOAD_STATS);
	
}

public client_disconnect(id)
{
	if(wczytalo[id])
		DodajWpis(id)
}
//========================================================
/// Uchwyt do bazy oraz wyczytanie i zapisanie danych
//========================================================
public sql_start()
{
	if ( !get_pcvar_num(p_Enabled))
		return;
	
	if(g_boolsqlOK) return;
	
	new szHost[64], szUser[32], szPass[32], szDB[128];
	
	get_pcvar_string( mysqlx_host, szHost, charsmax( szHost ) );
	get_pcvar_string( mysqlx_user, szUser, charsmax( szUser ) );
	get_pcvar_string( mysqlx_pass, szPass, charsmax( szPass ) );
	get_pcvar_string( mysqlx_db, szDB, charsmax( szDB ) );
	
	g_SqlTuple = SQL_MakeDbTuple(szHost, szUser, szPass, szDB);
	
	new q_command[2098]
	
	new iLen=0, iMax=sizeof(q_command) - 1
	
	iLen += formatex(q_command[iLen], iMax-iLen,"CREATE TABLE IF NOT EXISTS zm_osiagniecia_testy ( ")
	iLen += formatex(q_command[iLen], iMax-iLen,"`nick` VARCHAR(48) NOT NULL, ")
	iLen += formatex(q_command[iLen], iMax-iLen,"`ammopacks` INT(6) DEFAULT 0, ")
	iLen += formatex(q_command[iLen], iMax-iLen,"`dam_done` INT(12) DEFAULT 0, ")
	iLen += formatex(q_command[iLen], iMax-iLen,"`zm_kill` INT(6) DEFAULT 0, ")
	iLen += formatex(q_command[iLen], iMax-iLen,"`hm_infkill` INT(6) DEFAULT 0, ")
	iLen += formatex(q_command[iLen], iMax-iLen,"`deaths` INT(6) DEFAULT 0, ")
	iLen += formatex(q_command[iLen], iMax-iLen,"`nem_kill` INT(4) DEFAULT 0, ")
	iLen += formatex(q_command[iLen], iMax-iLen,"`sur_kill` INT(4) DEFAULT 0, ")
	iLen += formatex(q_command[iLen], iMax-iLen,"`ass_kill` INT(4) DEFAULT 0, ")
	iLen += formatex(q_command[iLen], iMax-iLen,"`sni_kill` INT(4) DEFAULT 0, ")
	iLen += formatex(q_command[iLen], iMax-iLen,"`matki_kill` INT(4) DEFAULT 0, ")
	iLen += formatex(q_command[iLen], iMax-iLen,"`last_hm_kill` INT(4) DEFAULT 0, ")
	iLen += formatex(q_command[iLen], iMax-iLen,"`czas_online` INT(6) DEFAULT 0, ")
	iLen += formatex(q_command[iLen], iMax-iLen,"`prze_human` INT(6) DEFAULT 0, ")
		
	iLen += formatex(q_command[iLen], iMax-iLen,"PRIMARY KEY (`nick`)) ")
	iLen += formatex(q_command[iLen], iMax-iLen,"DEFAULT CHARSET `utf8` COLLATE `utf8_general_ci`")
	
	SQL_ThreadQuery(g_SqlTuple, "QueryCreateTable", q_command);
}
public QueryCreateTable( FailState, Handle:hQuery, szError[ ], Errcode, iData[ ], iDataSize, Float:fQueueTime ) 
{
	if(FailState == TQUERY_CONNECT_FAILED) {
		log_to_file("sql_osiagniecia.log", "Could not connect to SQL database.");
		return PLUGIN_CONTINUE;
	}
	if(Errcode) {
		log_to_file("sql_ osiagniecia.log", "Error on Table query: %s", szError);
		return PLUGIN_CONTINUE;
	}
	if(FailState == TQUERY_QUERY_FAILED) {
		log_to_file("sql_osiagniecia.log", "Table Query failed.");
		return PLUGIN_CONTINUE;
	}
	g_boolsqlOK = 1;
	log_to_file("sql_osiagniecia.log", "Prawidlowe polaczenie");
	
	
	
	return PLUGIN_CONTINUE;
}


public Sprawdz_baze(id)
{
	id -= TASK_LOAD_STATS
	if(g_boolsqlOK)
		Loadstats(id)
	else
	{
		if(task_exists(id+TASK_LOAD_STATS))
			remove_task(id+TASK_LOAD_STATS)
		
		set_task(3.0, "Sprawdz_baze", id+TASK_LOAD_STATS);
	}
	return PLUGIN_CONTINUE;
}


public Loadstats(id)
{
	if(is_user_bot(id) || asked_sql[id])
		return PLUGIN_HANDLED;
	if(!module_exists("mysql"))
	{
		log_to_file("sql.log", "Modul mysql nie jest zaladowany gdy funkcja mysql sie odpala!");
		return PLUGIN_HANDLED;
	}
	
	if(g_boolsqlOK) {
		new data[1];
		data[0] = id;
		
		new name[48], q_command[2048];
		get_user_name(id, name, 47);
		replace_all(name, 47, "'", "\'");
		strtolower(name)
		
		formatex(q_command, 511, "SELECT * FROM `%s` WHERE `nick`='%s'", g_sqlTable, name);
		
		SQL_ThreadQuery(g_SqlTuple, "Load_stats_handle", q_command, data, 1);
		
		asked_sql[id] = 1;
	}
	else sql_start();
	
	return PLUGIN_HANDLED;
}
public Load_stats_handle(FailState, Handle:Query, Error[], Errcode, Data[], DataSize)
{
	new id = Data[0];
	asked_sql[id] = 0;
	
	
	if(FailState == TQUERY_CONNECT_FAILED) {
		log_to_file("sql.log", "Could not connect to SQL database.");
		return PLUGIN_CONTINUE;
	}
	if(FailState == TQUERY_QUERY_FAILED) {
		log_to_file("sql.log", "Load_xp Query failed.");
		return PLUGIN_CONTINUE;
	}
	if(Errcode) {
		log_to_file("sql.log", "Error on Load_xp query: %s", Error);
		return PLUGIN_CONTINUE;
	}
	
	if(SQL_MoreResults(Query))
	{
		for (new i = 0 ; i < LICZBA_OSIAGNIEC; i++){
			
			g_stats[id][i] = SQL_ReadResult(Query, i+1)
			ilosc[id][i] = 0
		}
		wczytalo[id] = true;
	}
	else
	{
		for (new i = 0 ; i < LICZBA_OSIAGNIEC; i++){
			
			g_stats[id][i] = 0
			ilosc[id][i] = 0
		}
		wczytalo[id] = true
	}
	wylicz(id)
	return PLUGIN_CONTINUE;
}


public TaskZapiszStats()
{
	if(g_boolsqlOK)
	{
		for(new id = 1; id <= 32; id++)
		{
			if(!is_user_connected(id) || is_user_hltv(id))
				continue;
			if(ilosc_wpisow >= 33)
			{
				ZakonczWpis_Zapiszstats();
			}
			DodajWpis(id);
		}
		ZakonczWpis_Zapiszstats()
	}
	else sql_start();
}
public ZakonczWpis_Zapiszstats()
{
	replace(ZapiszStats[giLen-1], giLen, ZapiszStats[giLen-1], "")
	
	giLen -= 1
	
	giLen += formatex(ZapiszStats[giLen], giMax-giLen," ON DUPLICATE KEY UPDATE   `ammopacks`=VALUES(`ammopacks`), `dam_done`=VALUES(`dam_done`), `zm_kill`=VALUES(`zm_kill`), `hm_infkill`=VALUES(`hm_infkill`), `deaths`=VALUES(`deaths`), ")
	giLen += formatex(ZapiszStats[giLen], giMax-giLen,"`nem_kill`=VALUES(`nem_kill`), `sur_kill`=VALUES(`sur_kill`), `ass_kill`=VALUES(`ass_kill`), `sni_kill`=VALUES(`sni_kill`), `matki_kill`=VALUES(`matki_kill`), `last_hm_kill`=VALUES(`last_hm_kill`), `czas_online`=VALUES(`czas_online`), `prze_human`=VALUES(`prze_human`)")
	
	log_to_file("test_zapis_osc.log", "%s", ZapiszStats);
	
	if(ilosc_wpisow > 0)
		SQL_ThreadQuery(g_SqlTuple, "ZapiszStatsHandle", ZapiszStats);
	else ResetujZapytanie();
	
	return;
}
public ZapiszStatsHandle(FailState, Handle:Query, Error[], Errcode, Data[], DataSize) {
	
	ResetujZapytanie()
	
	if(Errcode) {
		log_to_file("sql_osc.log", "Error on Save_xp query: %s", Error);
		return PLUGIN_CONTINUE;
	}
	if(FailState == TQUERY_QUERY_FAILED) {
		log_to_file("sql_osc.log", "Save_xp Query failed.");
		return PLUGIN_CONTINUE;
	}
	if(FailState == TQUERY_CONNECT_FAILED) {
		log_to_file("sql_osc.log", "Could not connect to SQL database.");
		return PLUGIN_CONTINUE;
	}
	
//	client_print(0, print_chat,"Exp zostal zapisany");
	
	return PLUGIN_CONTINUE;
}

public DodajWpis(id)
{
	if(!wczytalo[id] || is_user_hltv(id))
		return PLUGIN_CONTINUE;
	if(ilosc_wpisow >= 64)
	{
		ZakonczWpis_Zapiszstats();
	}
	new name[48];
	
	get_user_name(id, name, 47)
	replace_all(name, 47, "'", "\'")
	strtolower(name)
	
	giLen += formatex(ZapiszStats[giLen], giMax-giLen,"('%s',%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d),",name,g_stats[id][0],g_stats[id][1],g_stats[id][2],g_stats[id][3],g_stats[id][4],g_stats[id][5],g_stats[id][6],g_stats[id][7],g_stats[id][8],g_stats[id][9],g_stats[id][10],g_stats[id][11],g_stats[id][12])
	
	
	ilosc_wpisow++
	
	return PLUGIN_CONTINUE;
}

public ResetujZapytanie()
{
	ZapiszStats = ""
	ilosc_wpisow = 0
	giLen=0, giMax=sizeof(ZapiszStats) - 1
	giLen += formatex(ZapiszStats[giLen], giMax-giLen,"INSERT INTO `zm_osiagniecia_testy`(`nick`, `ammopacks`, `dam_done`, `zm_kill`, `hm_infkill`, `deaths`, `nem_kill`, `sur_kill`, `ass_kill`, `sni_kill`, `matki_kill`, `last_hm_kill`, `czas_online`,`prze_human`) VALUES ")
	
	return PLUGIN_CONTINUE;
}

public plugin_end() {
	if(g_SqlTuple != Empty_Handle)
	    {
		SQL_FreeHandle(g_SqlTuple) //free connection handle here
	    }
    
}
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang1045\\ f0\\ fs16 \n\\ par }
*/
